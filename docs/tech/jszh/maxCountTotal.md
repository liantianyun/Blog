# 总和最大区间问题（一）

在读《计算之魂》的第一章时，讲到了总和最大区间问题的四种时间复杂度不同的解法。

不过书中只是作了思路和复杂度分析，没有编码。

它正好是LeetCode第53题，那正好我就理论和实践相结合了，以此为契机锻炼一下算法的编码能力。

问题描述如下：

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例：

>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>
>输出：6
>
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

提示：
* 1 <= nums.length <= 10**5

这个问题如何对应现实问题呢？

你可以把数组里内容对应为一支股票每天的涨跌幅度，比如说实例中的数组，代表第1天跌两块，第二天涨一块，如果这段时间里你只能进行一次买卖操作，你能获得的最大收益是多少呢？

其实就是这段时间里最大连续子数组的和。

那么现在我们开始解题：

假设我们在第i天买( 1 <= i <= nums.length)，第j天( i < j <= nums.length)卖，用S(i,j)表示最段区间的收益和。

### 解法一：暴力穷举

那么第一种思路就很简单，把所有可能的i和j都试一遍，分别算出S(i,j)，然后找出最大的那个收益就行了。

我们按着这个思路用js编码如下：
```js
var maxSubArray = function(nums) {
    let max = -Infinity
    for(let i = 0; i < nums.length; i++) {
        for(let j = i + 1; j <= nums.length ; j ++) {
            max = Math.max(max, nums.slice(i, j).reduce(
                (total, cur) => total + cur, 0
            ))
        }
    }
    return max
};
```
这个算法的时间复杂度是多少呢？

i、j的遍历以及求和S(i,j)，都是时间复杂度为O(n)的操作，三者嵌套，所以这是一个复杂度为O(n**3)的算法。

实际上，用这段代码在leetCode提交时，第200个测试用例是无法通过的，因为时间复杂度太高性能太差导致运行超时了。


## 解法二：减少重复计算

那么我们接下来怎么改进一下呢？

我们仔细想一下，这上面有什么过程是存在重复计算的？

答案就在计算S(i,j)这一步，我们没必要每次j+1时，都重复计算一次，因为：

`S(i,j + 1) = S(i,j) + nums[j]`

如果抽象的思维不好理解的话，我们举个具体的例子，假设我们在第1天买入，第3天卖出，这时候我们算出这样操作的S(1,3) = -4,即亏四块钱，这时候我们假设卖出的推迟一天，即第四天卖出，那么这时候我们没必要重新从第一天开始累加，我们直接基于前三天的结果加上第四天的涨幅就可以了。

顺着这个思路，我们写出优化后的解法如下:
```js
var maxSubArray = function(nums) {
    let max = nums[0]
    for(let i = 0; i < nums.length; i++) {
        // 用一个数组缓存中间结果
        let rowSum = [nums[i]]
        for(let j = i + 1; j < nums.length ; j ++) {
            // 用最后一个元素的值加上当前值并缓存结果即可
            rowSum.push(rowSum[rowSum.length -1] + nums[j])
        }
        // 从缓存结果里找出最大值
        max = Math.max(max, Math.max(...rowSum))
    }
    return max
};
```
这个解法跟解法一的差别就在于内部求S(i,j)的时间复杂度变为了O(1)，所以算法的时间复杂度就变为了O(n**2),嗯，比刚刚好了一些，再次提交，多过了三个测试用例。

但还是无法全部的测试用例，这时候，我们可以看到，题目有个提示，数据量的大小在十万级，这无法通过测试。

可见，我们可以得出，对于十万级别的数据量，不能使用n**2级别的算法在leetcode提交题解。

那这个问题显然还需要我们去探索时间复杂度更低的办法。

篇幅太长，明天继续。
