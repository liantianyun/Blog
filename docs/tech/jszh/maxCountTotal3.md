# 总和最大区间问题（三）:线性复杂度的解法

题目:

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例：

>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
>
>输出：6
>
>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

提示：
* 1 <= nums.length <= 10**5

前文我们通过分治法想出了O(n* log n)级别的解法，今天我们来进一步探究下，看看是否有更优的O（n）复杂度级别的解法。

下面，我就把我的思考过程展现出来，一步步探索到解法。

既然我们的目标是O（n），也就是我们只能扫描常数遍数组，那我们的思路是在扫描过程中尽可能的得到更多的信息。

我们脑子里遍历一遍扫描过程，从第一个位置开始向后遍历，依次记录到当前位置的累加值。

接着，我们可以设想到，这个结果数组可能会是这样的:每加一个值，累加值可能变大，也可能变小，等到整个数组遍历完，一定在某个位置会有个最大值。

此时，我们思考这样一个问题：**这个最大值所在的位置，是否就是我要找的目标数组的右边界？如果是的话，那我是不是就解决了部分问题，问题转化成了，在已知右边界的情况下，找到左边界即可。**

这听上去是一个好注意，我们不妨顺着这个思路往下想，如果找到了右边界，怎么找左边界？很简单，如果上述找右边界的过程没有问题，我们逆序反过来再找一遍不就可以了吗？

那么整个问题就转化成了：**我们从头到尾扫一遍，并且记录每一个位置的累加值，能否断定，这个结果数组里的最大值，就是我们要找的区间的右边界？**

在思考这个问题之前，我们还可以先利用一些显而易见的结论帮我们简化问题。

比如说我们不一定要从头开始扫，我们的目标是找到最大的连续子数组和，所以我们可以把开头的非正数先去掉。

为什么呢？因为我们的目标是找到这个最大的连续子数组和。所以这个左边界的左边的值都是负数的话，如果这个左边界往左挪，那么这个和会变小，所以这个边界应该是在尽量靠右的正数位置开始的。

如果扫完了一遍发现没有正数怎么办？那说明这个数组全是负数，最大值就是整个数组的最大的那个负数。

这种情况很好处理，所以接下来我们假设的都是存在正数的数组。

当问题比较抽象的时候，我们可以借助例子，然后从例子去抽象，我们设想一组这样的数据。

`[3, 4,-10, 9]`

这个数组累加值如下:

`[3, 7,-3, 6]`

在这个结果数组里，最大的累计值是6，可是我们通过观察输入数据，很容易就发现，这个输入的最大值应该是9。

但结果数组里最大的值是7，所以我们至少可以断定，无法直接将7所在的位置作为目标数组的右边界。

那是否说明这个思路就不可行了呢？

不一定，我们在进一步思考一下，把上例的数据改一个值，改成:

`[3, 4,-6, 9]`

这时候得到的结果如下:

`[3, 4, 1, 10]`

这时候，10所在的位置是否就是目标数组的右边界？是的，这时候我们的设想又成立了。

它们之间的区别是什么呢？**两个输入之间唯一的差别就是这个-10和-6。**

这时候我们可以发现。在这个位置的左边的累加值是7，而-6和-10的差别就在于左边这个和加上这个值以后是否会降低到0以下。

如果没有降到0以下会意味着什么？意味着这个位置右边连续数组之和如果大于0，就可以继续跟前面的连续数组之和累加，累加出更大的和。

所以，**对于任意一个位置，如果这个位置右边的值始终满足:累加到该位置的和大于0，那么当整个序列扫描完成后，我们问题中的结论就是成立的。**

为什么呢？

我们的前提是这个数组任意位置累加值都是大于0的，那么对于任一位置，如果这个位置的右边还有一个更大的连续子数组的和的话，那么这个更大的值就会跟这个位置之前的和连接起来类加成更大的值，从而使得这个右边界始终在数组的最右侧，不会出现，明明后半部分的某段数组和更大，但是在结果数组里呈现时却小于前面的某个最大值的情况。

不好理解，就代入刚刚那个例子。

在第一个案例里，9本身比前面的最大累计值7大，之所以在结果数组里是6，是因为加上了-3，如果-3这个位置的值保证是大于0的，那么在结果数组里，9的位置所在的结果就必定大于7, 因为9 + 一个大于0的数 > 7。

一旦想通了这一点，这个题目就解的差不多了。

因为这个结论既然在特定前提下成立，我们就可以把问题转化成始终满足这个“特定前提”，然后再进一步想怎么找答案。

那么怎么转化呢？很简单，我们一旦遇到一个位置，使得到当前位置的累加值小于0了，我们就记录下这个位置前的最大连续子数组和，而这个位置后面的数组当作一个全新的数组来看，去重复这个过程，最终就相当于是在很多分段的**满足任意位置累加值大于0**的子序列里分别找到最大子数组和，然后取这里面的最大值即可。

为什么这些子序列的最大子数组和中的最大值就是整个数组的最大连续子数组和？

因为对于任意两个连续的子序列，它们之间的那一段子数组，加起来的值肯定是小于0的，你可以回顾我们刚刚的操作过程。

我们找到一个累加值（左边序列的和）小于0的位置后，往右找第一个正数，循环这个过程（中间排序排除掉的都是非正数）。

即:左边序列的和 、中间这一段非正数的和都小于0。

所以，如果你把左边序列的和 + 中间这一段非正数的和 + 右边序列的和，是必然小于右边序列的和的.

因此，对于任意两个子序列，整体最大值必定要么在左边，要么在右边，而不会出现在中间，多个序列和两个序列是一样的，因为你把两个处理完后，就可以用相同的方法证明前面的子数组之和永远小于最右边那一段最大值。



ok，思路很清晰了吧，接下来我们就来完成实际的编码过程。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    if (nums.length === 1) return nums[0]
    function getSubArrayMax(nums, start){
        let i = start
        // 先找到一个非负数
        while(nums[i] <= 0) {
            i++
        }
        //如果i已经到了nums.length，说明整个数组都是非正数
        if (i === nums.length) {
            return [Math.max(...nums.slice(start)), i]
        }
        let max = nums[i], sum = nums[i], r = i, rightBorder
        // 找右边界
        while(sum >= 0 && i < nums.length - 1) {
            i ++
            sum = sum + nums[i]
            if(sum > max) {
                max = Math.max(max, sum)
                r = i
            }
        }
        // 记录小于0的位置的临界值，用于返回
        rightBorder = i
        i = r
        // 找左边界
        while(nums[i] <= 0) {
            i--
        }
        let maxR = nums[i], l = i
        sum = nums[i]
        // 从右向左累加
        while(sum >= 0 && i > start) {
            i --
            sum = sum + nums[i]
            if(sum > maxR) {
                maxR = Math.max(maxR, sum)
                l = i
            }
        }
        sum = nums[l]
        i = l
        // 计算l,r的和
        while(i < r) {
            i++
            sum = sum + nums[i]
        }
        return [sum, rightBorder]
    }

    let i = 0, resMax = -Infinity
    while(i < nums.length -1){
        const [max, rightBorder] = getSubArrayMax(nums, i)
        resMax = Math.max(resMax, max)
        i = rightBorder
    }

    return resMax
};
```




