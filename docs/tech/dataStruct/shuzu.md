# 【LeetCode】简单的数组问题

今天刷了四个算法题，虽然是四个，但他们的解题思路和方法大致是一样的。

原来这就是套路，我可算明白了。

不过确实可以感觉到，对解题方法大致类似的题目进行大量的练习，确实可以很好的掌握一种核心方法，如果你善于总结，抽象思维能力不错，很快掌握一种方法。

这四个问题中，三个都是简单类型的题，只有一个是中等题。

有兴趣的小伙伴可以跟着刷下。

题目描述如下:

### 283.移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

示例：
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

解题思路：

本质上，这题需要把所有非0的元素，放到数组的前面来，所有0都放到后面去，并且非0元素的相对顺序不变，假设这个数组存在k个非0元素，那最后在那个的结果里，[0,k]则表示这些非0元素，扫描一遍数组，我们依次把非0元素往前提，同时把0交换到后面去，就可以了。

```js
var moveZeroes = function(nums) {
    function swap(nums, i, j) {
        const temp = nums[i]
        nums[i] = nums[j]
        nums[j] = temp
    }

    let k = 0
    for(let i = 0; i < nums.length; i++) {
        if(nums[i]){
            if(i !== k){
               swap(nums, i, k++)
            } else{
                k++
            }
        }
    }
    return nums
};
```

### 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例：
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

解题思路：
这题更简单了，你甚至不都需要交换元素，只要扫描一遍数组，把数组里面的不为val的值放到前k位就可以了

```js
var removeElement = function(nums, val) {

    let k = 0
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] !== val){
            nums[k++] = nums[i]
        }
    }
    return k
};
```

### 26. 删除有序数组中的重复项

给你一个升序排列的数组nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致 。然后返回nums中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

* 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
* 返回 k 。

示例：
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

解题思路：
跟上题类似，把非重复元素放到前k位即可。

```js
var removeDuplicates = function(nums) {
    let k = 0, size=0,cur
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] !== cur){
            nums[k++] = nums[i]
            cur = nums[i]
            size++
        }
    }
    return size
};
```

### 80. 删除有序数组中的重复项 II

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

示例：
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。

解题思路：这题就是那个中等题，确实稍微复杂点，但原理是一样的，都是把满足条件的元素放到前k位，只是这些条件的复杂程度，一定程度上你去判断，什么时候k该进行赋值、后移操作，什么时候什么都不做，仅仅是让扫描指针i后移。

```js
var removeDuplicates = function(nums) {
    // cur表示当前遍历元素，curCount表示当前遍历元素的重复次数
    let cur,curCount=0,k=0
    for(let i =0; i<nums.length;i++) {
        // 遇到与上一个遍历元素不同的值
        if(nums[i] !== cur){
            // 更新当前遍历的值，重置重复次数
            cur = nums[i]
            curCount=0
            // k位赋值并后移
            nums[k++] = nums[i]
            // 次数+1
            curCount++
        } else {
            // 遇到与上一个遍历相同的，如果出现次数小于2
            if(curCount < 2) {
                // k位赋值并后移
                nums[k++] = nums[i]
            }
            // 更新该cur出现的重复次数
            curCount++
        }
    }
    return k
};
```

上面那个2改成任意数字n都可以，相当于把题目改成重复元素至多出现n次。
