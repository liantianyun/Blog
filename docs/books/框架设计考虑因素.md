框架设计时需要考虑的内容：

* 模块并非相互独立、而是相互关联、相互制约。
* 作为学习者，应该从全局的角度对框架的设计有清晰的认知，否则容易被细节困住

1.1 命令式vs声明式

|范式|  特点 |  代表 |
| :------------: | :------------: | :------------: |
| 声明式  | 关注结果、内部封装过程  |  Vue、React |
| 命令式  | 关注过程  | Jquery  |

1.2 性能vs可维护性

结论：**声明式代码的性能不优于命令式代码的性能**

命令式框架直接修改dom，声明式框架找出dom变化的差异后修改dom，把直接修改dom的的性能消耗定位为A，找出差异的性能消耗为B，则：
* 命令式代码的更新性能消耗 = A
* 声明式代码的更新性能消耗 = B + A

即便B --> 0（理想状况，实际上并无可能），声明式代码最多做到与命令式代码的更新性能消耗相同，无法超越，印证结论。

|范式|  可维护性 |  性能 |
| :------------: | :------------: | :------------: |
| 声明式  | 高  |  一定程度损失 |
| 命令式  | 低  | 最高 |

框架目标：在保持可维护性的同时让性能损失最小化

1.3 虚拟Dom的性能到底如何?

虚拟Dom的出现目的：

结合1.2中的公式：声明式代码的更新性能消耗 = B + A

虚拟Dom正是为了令B趋近于0，即找出差异的代价最小化。

**理论上**，虚拟dom的更新性能不可能高于命令式的代码，但绝大多数情况下，用户很难写出完美的命令式代码，当应用规模较大、复杂度较高的时候，如果要写出完美的命令时代码，往往需要耗费开发者巨大的精力，**投入产出比不高**。

引申：innerHtml方法的性能如何

innerHtml的性能消耗 = 字符串的拼接计算量 + dom计算量
创建时：

|消耗层面|  innerHmtl方式 |  声明式框架方式 |
| :------------: | :------------: | :------------: |
| js计算层面  | 字符串拼接  |  创建新的js对象 |
| dom层面 | 新建所有dom  | 新建所有dom |

更新时：

|消耗层面|  innerHmtl方式 |  声明式框架方式 |
| :------------: | :------------: | :------------: |
| js计算层面  | 字符串拼接  |  创建新的js对象 + diff |
| dom层面 | 销毁所有旧的dom，新建所有dom  | 根据diff结果进行必要的更新 |
| 更新时的影响因素 | 与模板大小有关  | 与数据变化量有关 |

总结：

| 指标  | innerHtml  | 虚拟dom  | 命令式代码  |
| :------------: | :------------: | :------------: | :------------: |
| 心智负担 | 中  |  小 | 高  |
|  性能 |  低 |  中 |  高 |
|  可维护性 |  中 |  高 |  低 |

因此，综合来看，在考虑极端个例的情况下，虚拟dom绝大多数情况下是最优的编程范式。

1.4 运行时vs编译时

运行时：只提供render函数，用户调用时，需手动编写描述dom结构的对象
运行时编译：提供compile函数和render函数，运行时，先将用户提供的模板字符串编译为js对象，在调用render函数即可
编译时：直接将template编译成可运行的js代码，运行过程仍然存在，但不再需要框架需要提供render函数完成js对象到dom的转换，而是js运行编译后的代码直接完成该过程

|   | 优点  | 缺点  |
| :------------: | :------------: | :------------: |
| 运行时 | 不需要编译  |  无法分析用户输入 |
|  运行时+编译时 | 可以通过编译分析用于输入，提高运行时性能  | 理论性能低于编译时  |
|  编译时 |  性能最高 |  缺乏灵活性 |

1.5 总结

* 讲解了命令式、声明式的定义、分析了各自的特点
* 对比了不同编程范式的性能和可维护性
* 分析了虚拟dom的性能消耗，并综合对比innerHtml和命令式的心智负担、性能、可维护性等指标，得出虚拟在大多数情况下是最优选择的结论
* 分析对比了运行时和编译时的特点和优缺
