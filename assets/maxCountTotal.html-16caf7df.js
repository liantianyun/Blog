import{_ as n,p as s,q as a,a1 as p}from"./framework-5866ffd3.js";const t={},e=p(`<h1 id="总和最大区间问题-一" tabindex="-1"><a class="header-anchor" href="#总和最大区间问题-一" aria-hidden="true">#</a> 总和最大区间问题（一）</h1><p>在读《计算之魂》的第一章时，讲到了总和最大区间问题的四种时间复杂度不同的解法。</p><p>不过书中只是作了思路和复杂度分析，没有编码。</p><p>它正好是LeetCode第53题，那正好我就理论和实践相结合了，以此为契机锻炼一下算法的编码能力。</p><p>问题描述如下：</p><blockquote><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></blockquote><p>示例：</p><blockquote><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出：6</p><p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p></blockquote><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 10**5</li></ul><p>这个问题如何对应现实问题呢？</p><p>你可以把数组里内容对应为一支股票每天的涨跌幅度，比如说实例中的数组，代表第1天跌两块，第二天涨一块，如果这段时间里你只能进行一次买卖操作，你能获得的最大收益是多少呢？</p><p>其实就是这段时间里最大连续子数组的和。</p><p>那么现在我们开始解题：</p><p>假设我们在第i天买( 1 &lt;= i &lt;= nums.length)，第j天( i &lt; j &lt;= nums.length)卖，用S(i,j)表示最段区间的收益和。</p><h3 id="解法一-暴力穷举" tabindex="-1"><a class="header-anchor" href="#解法一-暴力穷举" aria-hidden="true">#</a> 解法一：暴力穷举</h3><p>那么第一种思路就很简单，把所有可能的i和j都试一遍，分别算出S(i,j)，然后找出最大的那个收益就行了。</p><p>我们按着这个思路用js编码如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">Infinity</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
                <span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> cur</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> total <span class="token operator">+</span> cur<span class="token punctuation">,</span> <span class="token number">0</span>
            <span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个算法的时间复杂度是多少呢？</p><p>i、j的遍历以及求和S(i,j)，都是时间复杂度为O(n)的操作，三者嵌套，所以这是一个复杂度为O(n**3)的算法。</p><p>实际上，用这段代码在leetCode提交时，第200个测试用例是无法通过的，因为时间复杂度太高性能太差导致运行超时了。</p><h2 id="解法二-减少重复计算" tabindex="-1"><a class="header-anchor" href="#解法二-减少重复计算" aria-hidden="true">#</a> 解法二：减少重复计算</h2><p>那么我们接下来怎么改进一下呢？</p><p>我们仔细想一下，这上面有什么过程是存在重复计算的？</p><p>答案就在计算S(i,j)这一步，我们没必要每次j+1时，都重复计算一次，因为：</p><p><code>S(i,j + 1) = S(i,j) + nums[j]</code></p><p>如果抽象的思维不好理解的话，我们举个具体的例子，假设我们在第1天买入，第3天卖出，这时候我们算出这样操作的S(1,3) = -4,即亏四块钱，这时候我们假设卖出的推迟一天，即第四天卖出，那么这时候我们没必要重新从第一天开始累加，我们直接基于前三天的结果加上第四天的涨幅就可以了。</p><p>顺着这个思路，我们写出优化后的解法如下:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">maxSubArray</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 用一个数组缓存中间结果</span>
        <span class="token keyword">let</span> rowSum <span class="token operator">=</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 用最后一个元素的值加上当前值并缓存结果即可</span>
            rowSum<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rowSum<span class="token punctuation">[</span>rowSum<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 从缓存结果里找出最大值</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>rowSum<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个解法跟解法一的差别就在于内部求S(i,j)的时间复杂度变为了O(1)，所以算法的时间复杂度就变为了O(n**2),嗯，比刚刚好了一些，再次提交，多过了三个测试用例。</p><p>但还是无法全部的测试用例，这时候，我们可以看到，题目有个提示，数据量的大小在十万级，这无法通过测试。</p><p>可见，我们可以得出，对于十万级别的数据量，不能使用n**2级别的算法在leetcode提交题解。</p><p>那这个问题显然还需要我们去探索时间复杂度更低的办法。</p><p>篇幅太长，明天继续。</p>`,35),o=[e];function c(l,u){return s(),a("div",null,o)}const r=n(t,[["render",c],["__file","maxCountTotal.html.vue"]]);export{r as default};
