import{_ as o,M as p,p as c,q as l,R as s,t as n,N as t,a1 as e}from"./framework-5866ffd3.js";const i={},u=s("h1",{id:"如何理解函数式组件",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#如何理解函数式组件","aria-hidden":"true"},"#"),n(" 如何理解函数式组件?")],-1),r={href:"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/",target:"_blank",rel:"noopener noreferrer"},k=e(`<p>我非常喜欢把函数作为组件这种编程方式，因为函数是JavaScript语言本身的特性，因此，如果组件即函数，那么关于函数的基础知识在组件里就仍然适用，而且函数非常容易编写，意味着组件也很容易创建，可以让组件变得非常的轻量化，有利于组件的拆分。</p><p>接着我们开始讲我准备讲解的内容。为了书写方便，我们接写来函数时组件统一简写为FC。</p><p>一个FC的基本结构是这样子的:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>    <span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先是各种变量声明、函数定义、hooks调用等</span>
        <span class="token keyword">const</span> a <span class="token operator">=</span> x
        
        <span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>defaultData<span class="token punctuation">)</span>
        
        <span class="token keyword">const</span> <span class="token function-variable function">anyFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
        
        <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        
        <span class="token comment">// 最后返回jsx</span>
        <span class="token keyword">return</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于这个结构，我们先讲解一些基本事实：</p><ul><li>一个组件就是一个普通的JavaScript函数，并没有什么特殊，即便是返回的JSX，经过编译后也是一个对象，因此，它就是一个返回对象的函数。</li><li>这个函数的返回值，会被React用于这个组件的渲染</li><li>每一次重新渲染的过程，就是重新调用这个函数，重新得到返回值的过程，因此，重新渲染等价于重新调用。</li><li>每一次调用函数，函数内的代码从第一行开始，直到遇到return语句，都会依次重新执行一遍，所以，中间定义的各种变量，hooks调用都会重新执行一遍</li></ul><p>ok，接下来我们看一个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleAlertClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&#39;You clicked on: &#39;</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Click me
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleAlertClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Show alert<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),d={href:"https://codesandbox.io/s/w2wxl3yo0l",target:"_blank",rel:"noopener noreferrer"},v=e("<p>现在，进行如下操作：</p><ol><li>点击count到3</li><li>此时点击另一个按钮</li><li>在3s计时器结束前，继续点击count到5</li></ol><p>现在请你判断，在计时器结束后，会输出什么？</p><p>答案是3。</p><p>其实答案不太重要，毕竟这个问题表面也就是让你在3和5之间选择而已，这个例子真正想让读者自省的是，答案为什么是3?你是否理解了以上操作步骤背后整个的react运作过程？</p><p>我们结合刚刚讲的几个基本事实来梳理这个过程。</p><ol><li>当我们进行第（1）步的时候，这个函数反复执行了三次，为什么会重新执行，这是useState这个hooks返回的setState的作用，当我们调用setState，为state赋一个新的值之后，下一次调用useState，返回的state就是这个新值，另外，每次重新调用这个函数，内部的<code>handleAlertClick</code>函数都会重新定义一次，也就是说，每一次重新渲染，在jsx里面每一次绑定的<code>handleAlertClick</code>函数都是跟上一次渲染绑定的引用时不同的了，但是第一次、第二次渲染时，这个函数不管是被定义也好，被绑定为点击处理事件的引用函数也好，都没有意义，因为没有用到过。</li><li>当count为3的时候，我们我们进行了步骤(2)，此时，第三次渲染时，定义的<code>handleAlertClick</code>函数被调用了，我们知道，函数被定义时，<strong>我们要会对内部的变量进行一个扫描，检测其中是否引用了非本函数内部定义的外部作用域的变量，如果有的话，那么不论这个函数在何时、何处被调用，他都可以始终访问到其内部的定义的这些外部作用域的变量，这是一个在代码编译阶段就会完成的过程，这个特性，在JavaScript里面被称为闭包</strong>。之所以叫闭包，可以形象的理解为，这个<strong>函数就像一个封闭的小背包，装着它里面的变量可以到处跑</strong>。我们可以看到，<code>handleAlertClick</code>函数内部是有一个访问外部变量的<code>count</code>的，我们知道，<code>[count, setCount]</code>这个语法其实是ES6的解构赋值语法，实际上每次执行的时候，我们都重新声明了一个count变量用于接收useState函数的返回值，因此，每一次执行时count变量的地址都是不一样的，所以每一次<code>handleAlertClick</code>函数定义的时候携带的闭包里面的count变量每次也都是不一样的，而第三次渲染时，<code>handleAlertClick</code>函数内部的携带的显示就是值3的那个count变量。</li><li>接着我们执行完步骤3，在我们加到5的过程中，函数又被重新执行了两次，又重复定义了count、handleAlertClick，但跟第一、二次一样，都没有意义，当3s计时器结束时，这个被setTimeout推入宏任务队列的函数内部携带的，其实是值为3的count，所以就输出了3。</li></ol><p>我不知道是否讲解的足够清晰，假设读者已经充分理解的情况下，我们可以看到，这整个过程的解释逻辑本质上跟react的关系不大，完全就是一些函数的基础知识，这也是我提到：如果<strong>组件即函数，那么关于函数的基础知识在组件里就仍然适用</strong>这句话的原因。</p><p>所以，我对函数式组件的理解就是：React的设计哲学就是希望用函数来描述组件，让组件编写的心智模型跟编写JavaScript函数时的心智模型统一，减少开发者的心智负担，所以我喜欢这个设计。这跟hooks是没有关系的，你把上例中的useState抠掉，这个组件顶多就是没有办法记录状态，退化为&quot;无状态&quot;而已，这种&quot;函数即组件&quot;的设计哲学仍然成立，实际上，在hooks出现之前，函数式组件就是被普遍称为&quot;无状态组件&quot;的。</p>",9);function m(b,h){const a=p("ExternalLinkIcon");return c(),l("div",null,[u,s("p",null,[n("今天读了一篇很好的文章，是讲解关于useEffect这个api的，叫"),s("a",r,[n("useEffect 完整指南"),t(a)]),n("，是react的核心维护者本人自己写的，这本文章写的很好，也很长，有点类似于迷你书（文中原话），还没看完的时候，我有一种自己想要出来讲讲我对于react函数式组件的理解的冲动。")]),k,s("p",null,[n("这个例子就是文章开头说的那篇文章里的，这个例子很简单，有两个按钮，一个是非常常见的计数器，另一个是一个按钮，点击后，调用setTimeout函数，3s后输出count的值。你可以点击"),s("a",d,[n("这里"),t(a)]),n("体验")]),v])}const g=o(i,[["render",m],["__file","understandFc.html.vue"]]);export{g as default};
