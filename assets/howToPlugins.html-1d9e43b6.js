import{_ as n,p as s,q as a,a1 as t}from"./framework-5866ffd3.js";const e={},p=t(`<h1 id="从userequest看一个库如何实现插件机制" tabindex="-1"><a class="header-anchor" href="#从userequest看一个库如何实现插件机制" aria-hidden="true">#</a> 从useRequest看一个库如何实现插件机制</h1><p>前文我们解读了useRequest的核心文件的源码，梳理了核心功能相关的逻辑，其中有提到，其是通过插件机制支持更多功能的拓展的，本文我们重点解读一下插件机制相关的代码：</p><ol><li>在<code>useRequestImplement</code>文件中，将所有的插件保存在fetchInstance的pluginImpls属性上</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>fetchInstance<span class="token punctuation">.</span>pluginImpls <span class="token operator">=</span> plugins<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span>fetchInstance<span class="token punctuation">,</span> fetchOptions<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>在Fetch类中，定义了<code>runPluginHandler</code>方法</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">runPluginHandler</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">event</span><span class="token operator">:</span> keyof PluginReturn<span class="token operator">&lt;</span>TData<span class="token punctuation">,</span> TParams<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token operator">:</span> any<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// @ts-ignore</span>
    <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>pluginImpls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> i<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token operator">?.</span><span class="token punctuation">(</span><span class="token operator">...</span>rest<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">...</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法的作用是接受一个事件名（对应前文提到的几个生命周期钩子），接着调用所有的插件中的对应名称的方法，将结果汇总在一个对象的属性上返回。</p><ol start="3"><li>接着，在真正的发起请求的方法<code>runAsync</code>中，存在调用插件的代码,我们先看下<code>onBefore</code>相关的:</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">const</span> <span class="token punctuation">{</span>
      stopNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      returnNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
      <span class="token operator">...</span>state
    <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runPluginHandler</span><span class="token punctuation">(</span><span class="token string">&#39;onBefore&#39;</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// stop request</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stopNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">loading</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      params<span class="token punctuation">,</span>
      <span class="token operator">...</span>state<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// return now</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>returnNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求开始前，传入<code>onBefore</code>作为参数调用了刚刚第2点提到的<code>runPluginHandler</code>方法，由此我们可以看到，插件的返回结果<code>stopNow</code>、<code>returnNow</code>、<code>state</code>是可以干预请求接下来的流程的</p><ul><li>如果某个插件返回了<code>stopNow</code>，请求就会被拦截</li><li>如果某个插件返回了<code>returnNow</code>，则只会调用请求开始前的插件hooks，并将结果进行<code>setState</code>传递到外界</li><li>插件返回的<code>state</code>也会被<code>setState</code>，根据上文提到的<code>setState</code>的机制，每次<code>setState</code>外层组件都会拿到数据并重新渲染组件，所以我们据此就可以判断，如果我们希望实现某种类似于缓存的机制，就可以从这里着手。</li></ul><ol start="4"><li>另外几个生命周期事件也是大致同理的、只要到了对应的时机调用传入对应的事件名调用<code>runPluginHandler</code>即可：</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// line 96</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runPluginHandler</span><span class="token punctuation">(</span><span class="token string">&#39;onSuccess&#39;</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// line 100、121 不论请求是否成功，只要请求未被取消（count的判断），try...catch都加上这一句</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>currentCount <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runPluginHandler</span><span class="token punctuation">(</span><span class="token string">&#39;onFinally&#39;</span><span class="token punctuation">,</span> params<span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// line 117 在try...catch的catch语句块中</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">runPluginHandler</span><span class="token punctuation">(</span><span class="token string">&#39;onError&#39;</span><span class="token punctuation">,</span> error<span class="token punctuation">,</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>这就是插件机制所有相关的代码，由于插件内部持有<code>fetchInstance</code>，所以它内部可以调用各种<code>fetchInstance</code>的接口，如进行<code>setState</code>操作等，这样可以在保持<code>useRequest</code>核心流程代码很清晰情况下，在请求的各个时机由插件进行对请求流程、结果的干预，从而实现更加丰富的各个功能。</p><p>以小见大，通过<code>useRequest</code>这个库，我们可以总结出一个库的插件机制的设计往往有这样的特点：</p><ul><li>核心库只实现它核心功能的流程</li><li>在这个流程执行中，在对应的时机开放对应的接口，并将核心对象传入插件，使其在此时能干预流程，做一些主流程未实现的事情，相当于拓展了库的功能</li><li>稍微想了下，你会发现<code>Vue</code>、<code>Webpack</code>也都是利用这样的机制实现插件系统的</li></ul><p>下文开始具体看各个插件的实现。</p>`,18),o=[p];function c(l,i){return s(),a("div",null,o)}const r=n(e,[["render",c],["__file","howToPlugins.html.vue"]]);export{r as default};
